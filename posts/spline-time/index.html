<!DOCTYPE html>
<html class="antialiased" lang="en">
  <head>



<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta http-equiv="X-UA-Compatible" content="ie=edge"/>
<title>spline time - Filoblog</title>
<link rel="canonical" href="https://filoxo.github.io/posts/spline-time/"/>
<meta property="og:site_name" content="Filoblog"/>
<meta property="og:title" content="spline time - Filoblog"/>
<meta property="og:type" content="website"/>
<meta property="og:url" content="https://filoxo.github.io/posts/spline-time/"/>


<link rel="icon" href="/favicon.svg" type="image/svg+xml"/>
<link rel="alternate icon" href="/favicon.ico" type="image/png" sizes="48x48"/>
<link rel="apple-touch-icon" href="/apple-touch-icon.png" sizes="192x192"/>
<link rel="mask-icon" href="/favicon.svg" color="#4a5568"/>
<meta name="theme-color" content="#4a5568"/>
<link crossorigin="anonymous" rel="stylesheet" href="/styles/style.css"/>
<link
  crossorigin="anonymous"
  rel="stylesheet"
  rel="preload"
  href="/styles/code.css"
  media="print"
  onload="this.media='all'; this.onload=null;"/>
<script type="module" src="/static/main.js" defer></script>
<!-- https://www.filamentgroup.com/lab/load-css-simpler/ --></head>
  <body class="bg-white text-gray-900 dark:bg-gray-900 dark:text-gray-100 relative">
    <div class="absolute z-[-1] inset-0 h-full min-h-screen w-full min-w-screen bg-[radial-gradient(#e5e7eb_1px,transparent_1px)] dark:bg-[radial-gradient(#efefef22_1px,transparent_1px)] [background-size:16px_16px] pointer-events-none"></div><header class="mx-auto py-4 mb-8 max-w-2xl px-3 md:px-6">
  <nav class="my-0 mx-auto flex max-w-2xl flex-wrap items-center justify-between">
    <h1 class="text-2xl font-semibold tracking-wide">
      <a class="uppercase transition-colors duration-300 ease-in-out hover:text-red-600" href="/">
        Filoblog
      </a>
    </h1>
    
    <ul class="m-0 flex items-center">
      <li>
        <a
          href="https://twitter.com/cfiloteo12"
          rel="noopener noreferrer"
          target="_blank"
          class="inline-flex p-2 transition-colors duration-300 ease-in-out hover:text-red-600">
          <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" height="24" width="24" xmlns="http://www.w3.org/2000/svg">
            <path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452
              0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568
              130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3
              27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431
              13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365
              109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137
              23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122
              60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"></path>
          </svg>
          <span class="sr-only">Follow me as @cfiloteo12 on Twitter</span>
        </a>
      </li>
      <li>
        <a
          href="https://github.com/filoxo"
          class="inline-flex p-2 transition-colors duration-300 ease-in-out hover:text-red-600">
          <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 480 512" height="24" width="24" xmlns="http://www.w3.org/2000/svg">
            <path d="M186.1 328.7c0 20.9-10.9 55.1-36.7 55.1s-36.7-34.2-36.7-55.1 10.9-55.1 36.7-55.1 36.7 34.2 36.7 55.1zM480 278.2c0
              31.9-3.2 65.7-17.5 95-37.9 76.6-142.1 74.8-216.7 74.8-75.8 0-186.2 2.7-225.6-74.8-14.6-29-20.2-63.1-20.2-95 0-41.9
              13.9-81.5 41.5-113.6-5.2-15.8-7.7-32.4-7.7-48.8 0-21.5 4.9-32.3 14.6-51.8 45.3 0 74.3 9 108.8 36 29-6.9 58.8-10 88.7-10
              27 0 54.2 2.9 80.4 9.2 34-26.7 63-35.2 107.8-35.2 9.8 19.5 14.6 30.3 14.6 51.8 0 16.4-2.6 32.7-7.7 48.2 27.5 32.4 39 72.3
              39 114.2zm-64.3 50.5c0-43.9-26.7-82.6-73.5-82.6-18.9 0-37 3.4-56 6-14.9 2.3-29.8 3.2-45.1 3.2-15.2
              0-30.1-.9-45.1-3.2-18.7-2.6-37-6-56-6-46.8 0-73.5 38.7-73.5 82.6 0 87.8 80.4 101.3 150.4 101.3h48.2c70.3 0 150.6-13.4
              150.6-101.3zm-82.6-55.1c-25.8 0-36.7 34.2-36.7 55.1s10.9 55.1 36.7 55.1 36.7-34.2 36.7-55.1-10.9-55.1-36.7-55.1z"></path>
          </svg>
          <span class="sr-only">I'm @filoxo on Github</span>
        </a>
      </li>
      <li>
        <a
          href="https://www.linkedin.com/in/carlosfiloteo/"
          class="inline-flex p-2 transition-colors duration-300 ease-in-out hover:text-red-600">
          <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 448 512" height="24" width="24" xmlns="http://www.w3.org/2000/svg">
            <path d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5
              32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2
              96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9
              27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"></path>
          </svg>
          <span class="sr-only">Let's connect on LinkedIn</span>
        </a>
      </li>
      <li>
        <div><label class="inline-flex relative items-center cursor-pointer mt-2 ml-2">
  <input type="checkbox" class="sr-only peer" aria-label="Toggle site theme" id="theme-toggle">
    <div class="w-9 h-5 bg-gray-800 rounded-full peer peer-focus:ring-4 peer-focus:ring-red-300 dark:peer-focus:ring-red-800
      dark:bg-gray-700 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute
      after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4
      after:transition-all dark:border-gray-600 peer-checked:bg-red-600"></div>
  </label></div>
      </li>
    </ul>
  </nav>
</header><div class="my-0 mx-auto max-w-2xl px-3 md:px-6">
      <div><article class="mb-12">
  <h1 class="mb-4 text-2xl text-red-600">spline time</h1>
  <p class="mb-4 text-red-600">20 May 2025</p>
  <div class="space-y-6">
    <div class="prose prose-headings:text-2xl prose-headings:font-normal prose-a:text-red-500 prose-code:rounded-sm prose-code:bg-gray-200 prose-code:px-1 prose-code:text-black prose-img:rounded-xl dark:prose-invert">
      <p>been playing with gen ai tools, such as Claude and Windsurf. i've had a decent amount of success with this model and i finally came up with something i would like to make with it - a spline scene that you can interact with.</p>
<p>the prompt was very simple and i was really happy with the output. <a href="https://claude.ai/share/99ab0ce9-bf31-4f3b-baac-0b11578ee362">here is the result from Claude</a>, which i then copied into this post, adapted a little bit, and then used Windsurf locally to update some of the issues. vibe coded while watching Murderbot with friends ðŸ™€</p>
<div id="scene"></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
  // Setup scene, camera, and renderer
  const container = document.getElementById("scene");
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientWidth, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer({ antialias: true });

  console.log(container.clientWidth)

  renderer.setSize(container.clientWidth, container.clientWidth);
  renderer.setClearColor(0x87CEEB); // Sky blue background
  container.appendChild(renderer.domElement);

  // Ambient light
  const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
  scene.add(ambientLight);

  // Directional light (like sunlight)
  const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 1);
  directionalLight.position.set(5, 10, 7.5);
  directionalLight.castShadow = true;
  scene.add(directionalLight);

  // Create ground (green plane)
  const groundGeometry = new THREE.PlaneGeometry(50, 50);
  const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x3CB371, side: THREE.DoubleSide });
  const ground = new THREE.Mesh(groundGeometry, groundMaterial);
  ground.rotation.x = Math.PI * -0.5;
  ground.position.y = -2;
  ground.receiveShadow = true;
  scene.add(ground);

  // Colors for the temple
  const stoneColor = 0xB5A642; // Brass/sandstone color
  const stepColor = 0x8B7355;  // Darker for steps/accents
  const templeColor = 0xCDC0B0; // Lighter for main structures

  // Create Aztec Temple
  function createAztecTemple() {
      const temple = new THREE.Group();
      
      // Base layers (pyramidal structure)
      const baseLayerCount = 5;
      let currentWidth = 16;
      let currentHeight = 0.8;
      
      for (let i = 0; i < baseLayerCount; i++) {
          // Create base layer
          const baseGeometry = new THREE.BoxGeometry(currentWidth, currentHeight, currentWidth);
          const baseMaterial = new THREE.MeshStandardMaterial({ color: stoneColor });
          const baseLayer = new THREE.Mesh(baseGeometry, baseMaterial);
          baseLayer.position.y = i * currentHeight;
          baseLayer.castShadow = true;
          baseLayer.receiveShadow = true;
          temple.add(baseLayer);
          
          // Create stairs for each side
          if (i < baseLayerCount - 1) {
              const nextWidth = currentWidth - 2;
              const stairWidth = currentWidth * 0.2;
              const stairDepth = (currentWidth - nextWidth) / 2;
              const stairGeometry = new THREE.BoxGeometry(stairWidth, currentHeight, stairDepth);
              const stairMaterial = new THREE.MeshStandardMaterial({ color: stepColor });
              
              // Front stairs
              const frontStairs = new THREE.Mesh(stairGeometry, stairMaterial);
              frontStairs.position.set(0, i * currentHeight + currentHeight / 2, currentWidth / 2 - stairDepth / 1.75);
              frontStairs.castShadow = true;
              frontStairs.receiveShadow = true;
              temple.add(frontStairs);
              
              // Back stairs
              const backStairs = new THREE.Mesh(stairGeometry, stairMaterial);
              backStairs.position.set(0, i * currentHeight + currentHeight / 2, -currentWidth / 2 + stairDepth / 1.75);
              backStairs.castShadow = true;
              backStairs.receiveShadow = true;
              temple.add(backStairs);
              
              // Left stairs
              const leftStairsGeometry = new THREE.BoxGeometry(stairDepth, currentHeight, stairWidth);
              const leftStairs = new THREE.Mesh(leftStairsGeometry, stairMaterial);
              leftStairs.position.set(-currentWidth / 2 + stairDepth / 1.75, i * currentHeight + currentHeight / 2, 0);
              leftStairs.castShadow = true;
              leftStairs.receiveShadow = true;
              temple.add(leftStairs);
              
              // Right stairs
              const rightStairs = new THREE.Mesh(leftStairsGeometry, stairMaterial);
              rightStairs.position.set(currentWidth / 2 - stairDepth / 1.75, i * currentHeight + currentHeight / 2, 0);
              rightStairs.castShadow = true;
              rightStairs.receiveShadow = true;
              temple.add(rightStairs);
          }
          
          currentWidth -= 2;
      }
      
      // Temple top (small building)
      const templeTopGeometry = new THREE.BoxGeometry(currentWidth * 0.8, 2, currentWidth * 0.8);
      const templeTopMaterial = new THREE.MeshStandardMaterial({ color: templeColor });
      const templeTop = new THREE.Mesh(templeTopGeometry, templeTopMaterial);
      templeTop.position.y = baseLayerCount * currentHeight + 1;
      templeTop.castShadow = true;
      templeTop.receiveShadow = true;
      temple.add(templeTop);
      
      // Temple door
      const doorGeometry = new THREE.BoxGeometry(1.2, 1.5, 0.5);
      const doorMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
      const door = new THREE.Mesh(doorGeometry, doorMaterial);
      door.position.set(0, baseLayerCount * currentHeight + 0.75, currentWidth * 0.4 + 0.25);
      temple.add(door);
      
      // Decorative elements - pillars
      const pillarGeometry = new THREE.CylinderGeometry(0.3, 0.3, 2, 8);
      const pillarMaterial = new THREE.MeshStandardMaterial({ color: stepColor });
      
      // Left pillar
      const leftPillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
      leftPillar.position.set(-currentWidth * 0.3, baseLayerCount * currentHeight + 1, currentWidth * 0.4);
      leftPillar.castShadow = true;
      temple.add(leftPillar);
      
      // Right pillar
      const rightPillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
      rightPillar.position.set(currentWidth * 0.3, baseLayerCount * currentHeight + 1, currentWidth * 0.4);
      rightPillar.castShadow = true;
      temple.add(rightPillar);
      
      // Top decoration
      const topDecorGeometry = new THREE.BoxGeometry(currentWidth * 0.6, 0.8, currentWidth * 0.4);
      const topDecorMaterial = new THREE.MeshStandardMaterial({ color: 0x8B0000 });
      const topDecor = new THREE.Mesh(topDecorGeometry, topDecorMaterial);
      topDecor.position.y = baseLayerCount * currentHeight + 2.5;
      topDecor.castShadow = true;
      temple.add(topDecor);
      
      return temple;
  }

  // Create and add the temple to the scene
  const temple = createAztecTemple();
  scene.add(temple);

  // Position camera
  camera.position.set(0, 10, 20);
  camera.lookAt(0, 5, 0);

  // Original camera position for reset
  const originalPosition = {
      x: camera.position.x,
      y: camera.position.y,
      z: camera.position.z
  };
  
  const originalLookAt = new THREE.Vector3(0, 5, 0);

  // Orbit control variables
  let isDragging = false;
  let previousMousePosition = {
      x: 0,
      y: 0
  };
  let orbitRadius = Math.sqrt(
      camera.position.x * camera.position.x + 
      camera.position.z * camera.position.z
  );
  let angleHorizontal = Math.atan2(camera.position.z, camera.position.x);
  let angleVertical = Math.atan2(
      Math.sqrt(camera.position.x * camera.position.x + camera.position.z * camera.position.z),
      camera.position.y - 5
  );
  
  // Variables to store starting angles when drag begins
  let startAngleHorizontal = angleHorizontal;
  let startAngleVertical = angleVertical;

  // Interaction event listeners - attach only to the container
  container.addEventListener('mousedown', onMouseDown);
  container.addEventListener('mouseup', onMouseUp);
  container.addEventListener('mousemove', onMouseMove);
  container.addEventListener('touchstart', onTouchStart, { passive: false });
  container.addEventListener('touchend', onTouchEnd);
  container.addEventListener('touchmove', onTouchMove, { passive: false });
  window.addEventListener('resize', onWindowResize);

  function onMouseDown(event) {
      isDragging = true;
      // Get coordinates relative to the container
      previousMousePosition = {
          x: event.offsetX,
          y: event.offsetY
      };
      
      // Store the starting angles when drag begins
      startAngleHorizontal = angleHorizontal;
      startAngleVertical = angleVertical;
  }

  function onMouseUp() {
      isDragging = false;
      resetCamera();
  }

  function onTouchStart(event) {
      event.preventDefault();
      isDragging = true;
      const rect = container.getBoundingClientRect();
      previousMousePosition = {
          x: event.touches[0].clientX - rect.left,
          y: event.touches[0].clientY - rect.top
      };
      
      // Store the starting angles when touch begins
      startAngleHorizontal = angleHorizontal;
      startAngleVertical = angleVertical;
  }

  function onTouchEnd() {
      isDragging = false;
      resetCamera();
  }

  function resetCamera() {
      // Animate camera back to original position
      const duration = 1000; // Reset duration in ms
      const startTime = Date.now();
      
      const startPosition = {
          x: camera.position.x,
          y: camera.position.y,
          z: camera.position.z
      };
      
      const startLookAt = new THREE.Vector3();
      camera.getWorldDirection(startLookAt);
      startLookAt.multiplyScalar(100).add(camera.position);
      
      function animateReset() {
          const elapsedTime = Date.now() - startTime;
          const progress = Math.min(elapsedTime / duration, 1);
          
          // Ease in-out function
          const easing = progress < 0.5 ? 2 * progress * progress : -1 + (4 - 2 * progress) * progress;
          
          camera.position.x = startPosition.x + (originalPosition.x - startPosition.x) * easing;
          camera.position.y = startPosition.y + (originalPosition.y - startPosition.y) * easing;
          camera.position.z = startPosition.z + (originalPosition.z - startPosition.z) * easing;
          
          camera.lookAt(0, 5, 0);
          
          if (progress < 1) {
              requestAnimationFrame(animateReset);
          }
      }
      
      animateReset();
  }

  function onMouseMove(event) {
      if (!isDragging) return;
      
      const deltaMove = {
          x: event.offsetX - previousMousePosition.x,
          y: event.offsetY - previousMousePosition.y
      };
      
      handleCameraMovement(deltaMove);
      
      previousMousePosition = {
          x: event.offsetX,
          y: event.offsetY
      };
  }

  function onTouchMove(event) {
      event.preventDefault();
      if (!isDragging) return;

      const rect = container.getBoundingClientRect();
      const touchX = event.touches[0].clientX - rect.left;
      const touchY = event.touches[0].clientY - rect.top;
      
      const deltaMove = {
          x: touchX - previousMousePosition.x,
          y: touchY - previousMousePosition.y
      };
      
      handleCameraMovement(deltaMove);
      
      previousMousePosition = {
          x: touchX,
          y: touchY
      };
  }

  function handleCameraMovement(deltaMove) {
      // Adjust rotation speeds (reduced for more control)
      const rotationSpeed = 0.003;
      
      // Define angle limits (15 degrees = Ï€/12 radians)
      const maxAngle = Math.PI / 12; // 15 degrees limit in any direction
      
      // Update angles based on mouse movement with reduced sensitivity
      angleHorizontal -= deltaMove.x * rotationSpeed;
      angleVertical += deltaMove.y * rotationSpeed;
      
      // Apply limits relative to where the drag started
      // Limit horizontal movement to Â±15 degrees from where drag started
      angleHorizontal = Math.max(startAngleHorizontal - maxAngle, 
                              Math.min(startAngleHorizontal + maxAngle, angleHorizontal));
      
      // Limit vertical movement to Â±15 degrees from where drag started
      // Also add absolute limits to prevent extreme angles
      const absoluteMinVertical = Math.PI / 4;      // 45 degrees (prevent looking too far up)
      const absoluteMaxVertical = 3 * Math.PI / 4;  // 135 degrees (prevent looking too far down)
      
      angleVertical = Math.max(
          Math.max(startAngleVertical - maxAngle, absoluteMinVertical),
          Math.min(Math.min(startAngleVertical + maxAngle, absoluteMaxVertical), angleVertical)
      );
      
      // Fixed orbit radius - prevent zooming in/out
      const fixedOrbitRadius = 20;
      
      // Calculate new camera position with constraints
      camera.position.x = fixedOrbitRadius * Math.cos(angleHorizontal) * Math.sin(angleVertical);
      camera.position.z = fixedOrbitRadius * Math.sin(angleHorizontal) * Math.sin(angleVertical);
      camera.position.y = fixedOrbitRadius * Math.cos(angleVertical) + 5; // +5 to focus on temple center
      
      // Always look at the temple center
      camera.lookAt(0, 5, 0);
  }

  function onWindowResize() {
      camera.aspect = container.clientWidth / container.clientWidth;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientWidth);
  }

  // Animation loop
  function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
  }

  animate();
</script>

    </div>
    <footer class="space-y-12">
      <p>Tagged with:&nbsp;<a
            href="/tags/javascript"
            class="border-b border-current text-red-500 no-underline transition-colors duration-300 ease-in-out visited:border-red-900 hover:text-red-600">javascript</a>
      ,&nbsp;<a
            href="/tags/gen-ai"
            class="border-b border-current text-red-500 no-underline transition-colors duration-300 ease-in-out visited:border-red-900 hover:text-red-600">gen-ai</a>
      </p>
      <div class="flex flex-row-reverse justify-between">
        <a
          class="border-b border-current text-red-500 no-underline transition-colors duration-300 ease-in-out hover:text-red-600"
          href="/">&larr; Back to home</a>
      </div>
    </footer>
  </div>
</article></div>
    </div><hr class="mt-4 mb-2 mx-auto w-48 h-0.5 bg-red-600 rounded border-0"/>
<footer class="my-0 mx-auto flex max-w-2xl flex-wrap items-center justify-between py-6 px-3 md:px-6">
  <p>
    i use this space to jot down ideas and thoughts relating to my work as a software dev, hobbies, and life in general.
    thanks for reading ðŸ¤˜
    <a
      href="/about"
      class="border-b border-current text-red-500 no-underline transition-colors duration-300 ease-in-out hover:text-red-600">
      more about me
    </a>
  </p>
</footer>
  </body>
</html>