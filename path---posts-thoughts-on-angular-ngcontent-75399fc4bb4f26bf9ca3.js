webpackJsonp([0x748484c7db11],{299:function(e,t){e.exports={data:{markdownRemark:{html:'<p>\n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 650px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 33.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAHABQDASIAAhEBAxEB/8QAFwABAAMAAAAAAAAAAAAAAAAAAAIEBf/EABYBAQEBAAAAAAAAAAAAAAAAAAMAAv/aAAwDAQACEAMQAAABq5YhyFr/xAAYEAACAwAAAAAAAAAAAAAAAAAAAQQREv/aAAgBAQABBQKVSZpn/8QAFxEBAAMAAAAAAAAAAAAAAAAAAAECEf/aAAgBAwEBPwGrIf/EABYRAQEBAAAAAAAAAAAAAAAAAAABEf/aAAgBAgEBPwGtr//EABkQAAEFAAAAAAAAAAAAAAAAAAABEBIxgf/aAAgBAQAGPwKCa1n/xAAZEAACAwEAAAAAAAAAAAAAAAABEQAQQXH/2gAIAQEAAT8hQ4h9UB6n/9oADAMBAAIAAwAAABAP7//EABcRAQEBAQAAAAAAAAAAAAAAAAEAEWH/2gAIAQMBAT8QAGFyv//EABcRAQADAAAAAAAAAAAAAAAAAAAhMWH/2gAIAQIBAT8QlbR//8QAHBAAAgEFAQAAAAAAAAAAAAAAAREAIUFRgZGx/9oACAEBAAE/EDzLiuFBoexQEgrs/9k=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"\n        alt=""Image of building angles""\n        title=""\n        src="/static/bldg-angle-dc2c93139ddaf804036841d8b81506a3-55338.jpg"\n        srcset="/static/bldg-angle-dc2c93139ddaf804036841d8b81506a3-a21e6.jpg 163w,\n/static/bldg-angle-dc2c93139ddaf804036841d8b81506a3-4ac53.jpg 325w,\n/static/bldg-angle-dc2c93139ddaf804036841d8b81506a3-55338.jpg 650w,\n/static/bldg-angle-dc2c93139ddaf804036841d8b81506a3-80f1d.jpg 975w,\n/static/bldg-angle-dc2c93139ddaf804036841d8b81506a3-245bf.jpg 1200w"\n        sizes="(max-width: 650px) 100vw, 650px"\n      />\n    </span>\n  </span>\n  </p>\n<p>I recently came across some interesting behavior with Angular\'s <code>ng-content</code> that I wanted to jot down so I can search for some answers. NgContent isn\'t well documented.</p>\n<h3>Why isn\'t <code>ng-content</code> self-closing?</h3>\n<p><code>ng-content</code> is to be used like any other element. This is great, especially for rendering in default content. For example, a component that can transclude some content but if for some reason nothing is nested into it, it will show a default state.</p>\n<pre><code>&#x3C;profile-card>\n    &#x3C;ng-content>\n        &#x3C;img src="/defaultProfile.jpg"/>\n        &#x3C;p>Unknown&#x3C;/p>\n    &#x3C;/ng-content>\n&#x3C;/profile-card>\n</code></pre>\n<p>But what if you don\'t need anything within the opening and closing tags? You\'d think that just <code>&#x3C;ng-content /></code> would be a nice and simple way to signal where to place the included content, but attempting to do so generates the following error:</p>\n<pre><code>Template parse errors: Only void and foreign elements can be self closed "ng-content"\n[ERROR ->]&#x3C;ng-content />\n</code></pre>\n<p>Seems weird to me. This may be by design.</p>\n<h3>Select is only able to find immediate children?</h3>\n<p>One of the features of <code>ng-content</code> is that you can use the <code>select</code> attribute on it to pull transcluded content into a specific location.</p>\n<pre><code>&#x3C;!-- my-component.html -->\n&#x3C;div>\n    &#x3C;ng-content select=".title">&#x3C;/ng-content>\n    &#x3C;ng-content select=".subtitle">&#x3C;/ng-content>\n&#x3C;/div>\n</code></pre>\n<p>This is great for enforcing layout in a specific way. Except... it has a <strong>major</strong> caveat, at least in my opinion. This select only seems to match <em>immediate children only</em>, nothing else.</p>\n<p>So using the above <code>my-component</code>, this belwo works while placing the <code>title</code> above the <code>subtitle</code>:</p>\n<pre><code>&#x3C;my-component>\n    &#x3C;p class="subtitle">world&#x3C;/p>\n    &#x3C;h2 class="title">Hello&#x3C;/h2>\n&#x3C;/my-component>\n</code></pre>\n<p>but then this doesn\'t! Nothing is rendered.</p>\n<pre><code>&#x3C;my-component>\n    &#x3C;div>\n        &#x3C;h2 class="title">Hello&#x3C;/h2>\n        &#x3C;p class="subtitle">world&#x3C;/p>\n    &#x3C;/div>\n&#x3C;/my-component>\n</code></pre>\n<p>It can\'t find these same elements  because they\'re wrapped in an extra div? I would have thought that it would match those elements as well, just like <code>querySelector</code> or CSS selectors would. If I only wanted immediate children I would have used something like <code>select="> .title"</code>. My assumption that it used standard selectors is wrong? ¯\\<em>(ツ)</em>/¯ That sucks.</p>',frontmatter:{date:"April 05, 2017",path:"/posts/thoughts-on-angular-ngcontent",tags:["angular"],title:"Thoughts on Angular: Ng-Content"}}},pathContext:{prev:{excerpt:'I sometimes see developers ask "Should I use React, or Angular, or Vue.js, or  [ insert new framework here ] ?" and every time, I see fanatics immediately jump to recommending one without any real justification. Now, I\'m no expert but I do have…',html:'<p>\n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 650px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 25.062447960033307%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAFABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAQF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAQL/2gAMAwEAAhADEAAAAZNEpjA//8QAGRAAAwADAAAAAAAAAAAAAAAAAQIDABIh/9oACAEBAAEFAk5koBg0xt//xAAWEQEBAQAAAAAAAAAAAAAAAAAAAgH/2gAIAQMBAT8BbEv/xAAXEQEAAwAAAAAAAAAAAAAAAAAAAQIS/9oACAECAQE/AbNS/8QAFxAAAwEAAAAAAAAAAAAAAAAAAAERIf/aAAgBAQAGPwKo0cP/xAAZEAEBAQEBAQAAAAAAAAAAAAABESEAMUH/2gAIAQEAAT8h0pEvn3rdY5hxjUBnf//aAAwDAQACAAMAAAAQg8//xAAXEQADAQAAAAAAAAAAAAAAAAAAAREx/9oACAEDAQE/EGyjD//EABcRAQEBAQAAAAAAAAAAAAAAAAEAETH/2gAIAQIBAT8QaMYdv//EABkQAQADAQEAAAAAAAAAAAAAAAEAETEhUf/aAAgBAQABPxCzIqHAEOMHPMBDx9jNlwJeM//Z\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"\n        alt="\'Oil in water\'"\n        title=""\n        src="/static/oil-in-water-865895b547501f0b93e81e75a00f5050-55338.jpg"\n        srcset="/static/oil-in-water-865895b547501f0b93e81e75a00f5050-a21e6.jpg 163w,\n/static/oil-in-water-865895b547501f0b93e81e75a00f5050-4ac53.jpg 325w,\n/static/oil-in-water-865895b547501f0b93e81e75a00f5050-55338.jpg 650w,\n/static/oil-in-water-865895b547501f0b93e81e75a00f5050-80f1d.jpg 975w,\n/static/oil-in-water-865895b547501f0b93e81e75a00f5050-81b9d.jpg 1201w"\n        sizes="(max-width: 650px) 100vw, 650px"\n      />\n    </span>\n  </span>\n  </p>\n<p>I sometimes see developers ask "Should I use React, or Angular, or Vue.js, or <em>[insert new framework here]</em>?" and every time, I see fanatics immediately jump to recommending one without any real justification. Now, I\'m no expert but I do have experience with both Angular and React. This post lists some of the differences between the actual usage of Angular (2+) and React. I hope to just shed some light on the practical differences between them to help you understand the decision a bit better.</p>\n<h3>Complexity</h3>\n<p>Frameworks are abstractions to help reduce the complexity of building an application. Frameworks in turn introduce their own complexity. First, let\'s establish that each framework falls somewhere on a complexity spectrum.<a href="#vuejsTalk">¹</a></p>\n<p><img src="/assets/framework-spectrum.jpg" alt="Framework Complexity Spectrum"></p>\n<p>This is the first problem: <strong>React and Angular are at different points of the complexity spectrum</strong>. They\'re solving problems in different ways, and will never be equal to each other in scope. Using another analogy, they\'re different tools for different and various jobs; some of those jobs overlap, others don\'t.</p>\n<p>For the most part, choosing between them based on this alone is <strong>moot</strong>. Why? Because React is "unopinionated" so you bring your own solution to solve problem X. Inversely, Angular provides many tools together into one framework. It is not an apples-to-apples comparison.</p>\n<h4>Complexity: React</h4>\n<p>Let\'s start with React here. React is not a complete framework, you are required to bring in dependencies on your own. This is can be great but also daunting. Not all developers who work on the web know about the very latest libs, are proficient with <code>npm</code> or <code>yarn</code>, or can set up an ES6 project to transpile down to ES5.</p>\n<p>In an enterprise setting, choosing a library might need more consideration than "just because". Does the lib\'s license allow enterprise use? What if an engineering manager needs to know the difference between various libs? Which library contains enough features to support future projects/requirements?</p>\n<p>A personal experience of this I had is choosing an HTTP library. There are so many great choices! Some of the ones I\'ve looked at to use with React are:</p>\n<ul>\n<li><a href="https://github.com/mzabriskie/axios">Axios</a></li>\n<li><a href="https://github.com/visionmedia/superagent">Superagent</a></li>\n<li><a href="https://github.com/petkaantonov/bluebird">Bluebird</a></li>\n<li><a href="https://github.com/github/fetch">Fetch</a></li>\n<li><a href="https://github.com/developit/unfetch">Unfetch</a></li>\n</ul>\n<p>The company I work for is slowly coming around to adopting React but what\'s there to stop each team from choosing a different lib from of the above? Allowing this sort of fragmentation makes it that much harder to share code and contribute to other teams. Furthermore, making a decision to standardize one requires intimate knowledge of the features, benefits, and disadvantages of each.</p>\n<p>Now, <em>this evaluation process isn\'t bad</em>! It would GREAT to make a thorough and informed decision but not every developer or team is equipped to make this kind of analysis for every dependency. If this isn\'t something that you or your team can or want to do, then consider a full framework like Angular. Conversely, if developers are passionate about jumping in and learning each lib quickly then this isn\'t a problem.</p>\n<h4>Complexity: Angular</h4>\n<p>With Angular you\'re getting many of libraries together from a single source, compatible and tested. Angular is an abstraction built on top of a component model, TypeScript, RxJS, Webpack, to name a few. The advantages I see here are:</p>\n<ul>\n    <li>Documentation exists showing how to use each lib within context of the framework</li>\n    <li>Each standard lib will be compatible and integrates better than external libs might</li>\n    <li>a solution is already "chosen" for you by the time you encounter a problem to be solved</li>\n    <li>Angular\'s implementation of semver means that most updates will follow a compatible rhythm</li>\n</ul>\n<p>There are some disadvantages:</p>\n<ul>\n    <li>You\'re getting a whole lot of framework to have to learn together, the learning curve here can be steep and overwhelming</li>\n    <li>Angular\'s documentation is not the very best</li>\n    <li>there\'s no sensibility in trying to replace one part of the framework for another lib</li>\n    <li>Full-frameworks can add in a lot of code that you don\'t use<sup>*</sup></li>\n    <li>Re-using the Angular namespace means that there\'s a lot of conflation between AngularJS (version 1) and Angular (2+)</li>\n</ul>\n<p><sup>*</sup>Both frameworks, if configured properly, discards unused dependencies from a production build (a process known as tree-shaking).</p>\n<h3>Framework</h3>\n<p>React\'s model of a single component drives to you really want to keep your components tiny, and import the rest. On average, my React components stay at less than 50 lines. Keeping components tiny really helps with composability.\nAngular uses a similar component model, but requires at least 10+ lines just to declare, along 2 accompanying files—a template file and a style file. Keeping the template separate has had an unforeseen consequence: templates get <em>huge</em> and end up more bloated than needed. Because of this, I feel like there\'s a desire to add more logic to the class than a single component actually needs. Its all to easy to bloat a single component instead of breaking it out into smaller pieces.</p>\n<h3>Tools</h3>\n<p>React has <a href="https://github.com/facebookincubator/create-react-app">create-react-app</a>, a very small commandline tool to generate a React project. It\'s purposefully pretty bare bones and new features are only added with much consideration and discussion. In my subjective experience, I\'ve found that a sizable number of people chose to eject so that they have more control over their build config. This usually happens when they seek to include a feature/build step that CRA can\'t/won\'t include.</p>\n<p>Angular has the <a href="https://github.com/angular/angular-cli">angular-cli</a>, a very functional commandline tool that pulls together a great number of useful features:</p>\n<ul>\n<li>Generator (like Yeoman)</li>\n<li>Dev server with live reload (using webpack-dev-server)</li>\n<li>Preconfigured css preprocessing (Sass, Less, or Stylus)</li>\n<li>Preconfigured linting (tslint)</li>\n<li>Preconfigured testing (Karma)</li>\n<li>Build configuration for dev &#x26; production</li>\n</ul>\n<p>The Angular CLI has become much more robust and helps many devs quickly achieve things that might take much more manual configuration and experience. I\'ve very much enjoyed using the Angular CLI. The biggest issue I\'ve had with it are bad configurations: retroactive upgrades, version mismatches, or borked upgrades.</p>\n<h4>Ecosystem: React</h4>\n<p>React, backed by Facebook, has been favored by many developers and companies, like Microsoft and Samsung. React is the <strong>#1</strong> most-loved and 3rd most wanted framework<a href="#StackOverflowDeveloperSurvey2017">²</a> according to StackOverflow\'s 2017 Developer Survey. There are tons of React-based projects (this blog uses <a href="https://phenomic.io/">Phenomic</a>! 🤘 ) as well as React components. React\'s single-responsibility model has led to development of other great community-driven libraries that can enhance your app\'s functionality. Projects like <a href="https://github.com/ReactTraining/react-router">React Router</a>, <a href="http://redux.js.org/">Redux</a>/<a href="https://github.com/mobxjs/mobx">MobX</a>, and React Native have all sprouted and thrived under <a href="https://twitter.com/ryanflorence/status/869732167814848512">the big React tent</a>.</p>\n<p>Even more interesting, <a href="https://preactjs.com/">Preact</a> and <a href="https://infernojs.org/">Inferno</a> are <em>"almost drop-in"</em> alternatives that have same/similar API; I find that many developers using React have literally never heard of either 🤔 yet these can offer even better performance for many apps.</p>\n<p>React\'s ecosystem is as prolyfic as one could hope for.</p>\n<h4>Ecosystem: Angular</h4>\n<p>Angular on the other hand feels very much like "corporate" or enterprise softare. The API very much feels like <em>This is how we solved this problem, and you get to use it that way</em>. Regardless, adoption of Angular 2 has not lagged behind at all.</p>\n<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">1.3 million people use Angular 1.<br>480k already use Angular 2.</p>&mdash; David East (@_davideast) <a href="https://twitter.com/_davideast/status/776244105261133824">September 15, 2016</a></blockquote>\n<script defer src="//platform.twitter.com/widgets.js" charset="utf-8"></script>\n<p>And this quote is somewhat old; these numbers have most likely increased. Angular ranks very high as a popular framework: 6th most loved, 4th most dreaded, and 2nd most wanted<a href="#StackOverflowDeveloperSurvey2017">²</a> <a href="#footnote2">³</a></sup>.</p>\n<p>The Angular ecosystem is not quite as expansive, but has Google\'s weight behind the rest of their products to push out additional libraries that align with Angular. What that means is companion projects like <a href="https://github.com/angular/material2">Angular Material</a>, <a href="https://github.com/angular/angularfire2">AngularFire2</a>, and <a href="https://github.com/angular/universal">Angular Universal</a> are kept up to date with the Angular core. Aside from these projects there aren\'t as many thriving projects built for Angular as I\'d like to see. Many of these have gotten out of date very fast.</p>\n<p>TypeScript has seen some great progress and adoption in the JS community as a whole; its the 3rd most loved and 6th most wanted language of 2017<a href="#StackOverflowDeveloperSurvey2017">²</a>! Furthermore, a success with TypeScript that I\'ve experienced is that it makes backend developers a more comfortable writing JavaScript. It enables bringing in some concepts that can help make a webapp more robust, in addition to being an ES6 transpiler. Learning TypeScript\'s features and syntax was not difficult.</p>\n<p>The most difficult part of using TypeScript is finding the correct type definitions (typings) to go along with your dependent libs. Most are available via npm under the <code>@types</code> namespace but if that isn\'t the case, you lose the main benefit of TypeScript in the first place: type safety. At the same time, that\'s no reason not to use Angular! It would make the developer all that better by taking the initiative to contribute the types. Yay for open source software! But this is a challege that you may face with Angular.</p>\n<h3>Conclusion</h3>\n<p>This long-winded explanation is really just to say: Don\'t choose between React and Angular just because you\'re a fan of one. <strong>Choose the one that fits your project\'s requirements; the one whose risks and challenges you\'re willing to accept; the one that is the sane investment considering the needs of the developer, team, and business.</strong> Ultimately, both frameworks are backed by major companies. Both have great developers that lead them, and communities surrounding them. Both solve complex problems and can be used to build great web apps.</p>\n<p>If you can, don\'t lock yourself into one. Always keep learning about what else can solve the problem at hand. ✌️</p>\n<hr>\n<small>\nFootnotes:\n<ul>\n<li><a name="vuejsTalk" href="https://www.youtube.com/watch?v=pBBSp_iIiVM" target="_blank">1: "Vue.js: the Progressive Framework"</a></li>\n<li><a name="StackOverflowDeveloperSurvey2017" href="https://insights.stackoverflow.com/survey/2017" target="_blank">2: StackOverflow Developer Survey 2017</a></li>\n<li><a name="footnote2">3: </a> I don\'t think the survey properly distinguishes between AngularJS (version 1) and Angular (2+). It would be interesting to see the stats with these two versions divided.</li>\n</ul>\n</small>',id:"/Users/cfiloteo/dev/blog/src/pages/2017-05-31-practical-thoughts-on-react-and-angular/index.md absPath of file >>> MarkdownRemark",timeToRead:8,frontmatter:{date:"2017-05-31T00:00:00.000Z",path:"/posts/practical-thoughts-on-react-and-angular",tags:["angular","react"],title:"Practical thoughts on React and Angular"}},next:{excerpt:"This last weekend I wanted to create a simple CSS framework that I can reuse for my own little projects. The end result is  Simple Style  (which is still a WIP as requirements come up). Surprisingly, using  npm as a build tool  made it extremely easy…",html:'<p>\n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 650px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 25%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAFABQDASIAAhEBAxEB/8QAFwABAAMAAAAAAAAAAAAAAAAAAAIDBP/EABUBAQEAAAAAAAAAAAAAAAAAAAME/9oADAMBAAIQAxAAAAG6IFGsKP8A/8QAGBABAQADAAAAAAAAAAAAAAAAAQIDEjP/2gAIAQEAAQUCKd7qgx8//8QAFxEAAwEAAAAAAAAAAAAAAAAAAAEDMf/aAAgBAwEBPwGaHp//xAAVEQEBAAAAAAAAAAAAAAAAAAAQQv/aAAgBAgEBPwGj/8QAGBABAAMBAAAAAAAAAAAAAAAAAAECETH/2gAIAQEABj8Cl1XX/8QAFxABAQEBAAAAAAAAAAAAAAAAAQAhEf/aAAgBAQABPyEB2Qc1bTy//9oADAMBAAIAAwAAABB8H//EABYRAQEBAAAAAAAAAAAAAAAAAAEAMf/aAAgBAwEBPxAHS2v/xAAVEQEBAAAAAAAAAAAAAAAAAAAQUf/aAAgBAgEBPxCD/8QAGRABAAMBAQAAAAAAAAAAAAAAAQARIUFh/9oACAEBAAE/ELRYNHmEN1E6R0LNr2f/2Q==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"\n        alt=""Leaves""\n        title=""\n        src="/static/leaves-add274474afb2aa4bd26d33be9de68c4-55338.jpg"\n        srcset="/static/leaves-add274474afb2aa4bd26d33be9de68c4-a21e6.jpg 163w,\n/static/leaves-add274474afb2aa4bd26d33be9de68c4-4ac53.jpg 325w,\n/static/leaves-add274474afb2aa4bd26d33be9de68c4-55338.jpg 650w,\n/static/leaves-add274474afb2aa4bd26d33be9de68c4-80f1d.jpg 975w,\n/static/leaves-add274474afb2aa4bd26d33be9de68c4-245bf.jpg 1200w"\n        sizes="(max-width: 650px) 100vw, 650px"\n      />\n    </span>\n  </span>\n  </p>\n<p>This last weekend I wanted to create a simple CSS framework that I can reuse for my own little projects. The end result is <a href="https://github.com/filoxo/simple-style">Simple Style</a> (which is still a WIP as requirements come up). Surprisingly, using <a href="https://medium.com/@dabit3/introduction-to-using-npm-as-a-build-tool-b41076f488b0#.5w4loc8uy">npm as a build tool</a> made it extremely easy to set up a dev environment. I\'ll review everything about the setup in this post for my own documentation, but hopefully can also serve as a clean, straightforward example.</p>\n<p>I used <a href="https://yarnpkg.com/en/"><code>yarn</code></a> for this experiment instead of <code>npm</code> solely for the speed improvements. Fortunately, <code>yarn</code>\'s commands all have their <code>npm</code> equivalents so don\'t get hung up on the differences.</p>\n<p>This basic setup offers:</p>\n<ul>\n<li>Autoprefixing to support the 2 latest browsers</li>\n<li>Future CSS syntax usable today</li>\n<li>minification</li>\n<li>optimizations</li>\n<li>a quick and easy development setup to reflect changes on-the-fly</li>\n</ul>\n<h3>Dev dependencies</h3>\n<p>Here are our initial development dependencies:</p>\n<ul>\n<li><a href="https://necolas.github.io/normalize.css/">normalize.css</a>: so that all elements render consistently</li>\n<li><a href="https://github.com/postcss/postcss">PostCSS</a>\'s CLI: to leverage its ecosystem of feature plugins</li>\n<li><a href="http://cssnext.io/">CSSnext</a>: a PostCSS plugin that helps you to use the latest CSS syntax today. This way the code will be a little more future-proof. Additionally, CSSnext also includes <a href="https://github.com/postcss/autoprefixer">Autoprefixer</a> as a dependency.</li>\n<li><code>postcss-import</code>: used to pull in a css file that wasn\'t being preprocessed</li>\n<li><code>cssnano</code>: minify and optimize output</li>\n</ul>\n<p>Install using yarn (or the npm equivalent)</p>\n<pre><code>yarn add -D normalize.css postcss-cli postcss-cssnext postcss-import cssnano\n</code></pre>\n<h3>PostCSS config</h3>\n<p>Create a json file that contains the config for PostCSS. The docs named it <strong>options.json</strong> but I choose <strong>postcss.json</strong> for better clarity. The comments below explain some keys.</p>\n<pre><code>{\n    // Enable plugins in order\n    "use": [\n        "postcss-import",\n        "postcss-cssnext",\n        "cssnano"\n    ],\n    "input": "main.css",\n    "output": "dist/main.css",\n    // use locally installed plugins (eg. in node_modules)\n    "local-plugins": true,\n    // Enable sourcemaps\n    "map": true,\n    // CSSnext and cssnano both use autoprefixer, but for different features/purposes\n    // see https://github.com/MoOx/postcss-cssnext/issues/323\n    "postcss-cssnext": {\n        "warnForDuplicates": false\n    }\n}\n</code></pre>\n<h3>CSS time</h3>\n<p>Go ahead and create <strong>main.css</strong> at the project root. The above config will output to <strong>dist/</strong>. Here\'s a quick sample to put into the file for now.</p>\n<pre><code>@import(\'normalize.css\');\n\n:root {\n    --color-primary: blue;\n    --color-secondary: red;\n}\n</code></pre>\n<h3>Building</h3>\n<p>Use the postcss-cli with the config file passed in as an arg and save it as an npm script.</p>\n<pre><code>"scripts": {\n    "build": "node_modules/postcss-cli/bin/postcss -c postcss.json"\n}\n</code></pre>\n<p>Now you can simply run <code>yarn run build</code> and your css will be processed and output to <strong>dist</strong>. But we can still do better.</p>\n<h3>Watch for changes</h3>\n<p>Enabling watch will auto-transform the css file on changes. Add another npm script, which is exactly the same as <code>build</code> but with the watch flag.</p>\n<pre><code>"build:dev": "node_modules/postcss-cli/bin/postcss -c postcss.json -w"\n</code></pre>\n<h3>Livereload</h3>\n<p>You wouldn\'t develop a CSS framework without seeing it rendered on a page so let\'s create a test page for development. Create <strong>index.html</strong> at the project root and populate it with some HTML, and add a link to your <strong>main.css</strong> file.</p>\n<pre><code>&#x3C;!doctype html>\n&#x3C;html lang="en-US">\n    &#x3C;head>\n        &#x3C;link rel="stylesheet" href="/dist/main.css">\n    &#x3C;/head>\n    &#x3C;body>\n        &#x3C;main>Hello world&#x3C;/main>\n    &#x3C;/body>\n&#x3C;/html>\n</code></pre>\n<p><a href="https://www.npmjs.com/package/lr-http-server"><code>lr-http-server</code></a> will reload on changes, as well as a functioning http server.</p>\n<pre><code>yarn add -D lr-http-server\n</code></pre>\n<p>And then register a new npm script for it</p>\n<pre><code>"reload": "lr-http-server -p 3000"\n</code></pre>\n<h3>Composing scripts</h3>\n<p>We want the two above scripts to run in parallel so that if either the css or the html file changes the livereload server will do its job. <a href="https://www.npmjs.com/package/npm-run-all"><code>npm-run-all</code></a> with the <code>-p</code> (parallel) flag does this exactly.</p>\n<pre><code>yarn add -D npm-run-all\n</code></pre>\n<p>Join the two tasks together into a single npm script</p>\n<pre><code>"start": "npm-run-all -p build:dev reload"\n</code></pre>\n<p>And then run easily with</p>\n<pre><code>yarn start\n</code></pre>\n<h3>Done!</h3>\n<p>You\'re ready to keep going developing your styles inside <strong>main.css</strong>. Feel free to improve upon this as needed!</p>',id:"/Users/cfiloteo/dev/blog/src/pages/2017-02-14-build-a-css-framework-using-npm/index.md absPath of file >>> MarkdownRemark",timeToRead:4,frontmatter:{date:"2017-02-14T00:00:00.000Z",path:"/posts/build-a-css-framework-using-npm/",tags:["javascript","npm"],title:"Building a CSS framework using npm"}}}}}});
//# sourceMappingURL=path---posts-thoughts-on-angular-ngcontent-75399fc4bb4f26bf9ca3.js.map