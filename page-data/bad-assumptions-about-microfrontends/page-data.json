{"componentChunkName":"component---src-templates-post-js","path":"/bad-assumptions-about-microfrontends/","webpackCompilationHash":"40b833915e9f22a923ec","result":{"data":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Bad Assumptions about Microfrontends\",\n  \"date\": \"2019-08-09T00:00:00.000Z\",\n  \"tags\": [\"javascript\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"There've been some surprisingly incorrect assumptions being made about \\\"microfrontends\\\" since it became a buzzword. Microservices in the browser (I prefer this term over microfrontends) are a totally new paradigm but these bad takes seem to have quite a bit of reach. I'll tackle some of these in this post. \"), mdx(\"h2\", null, \"Multiple frameworks\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"The idea really is that you might build a React app and I build a Vue app and we'll slap 'em together on the same page. I definitely come from an era where we laughed-then-winced when we found sites that used multiple versions of jQuery on the same page... We winced because that was a bucket full of JavaScript, mostly duplicated for no reason, causing bugs and slowing down the page. This doesn't seem all that much different.\"), mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Chris Coyier, \", mdx(\"a\", _extends({\n    parentName: \"em\"\n  }, {\n    \"href\": \"https://css-tricks.com/micro-frontends/\"\n  }), \"https://css-tricks.com/micro-frontends/\")))), mdx(\"p\", null, \"This is actually a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"huge\"), \" mischaracterization. Think about this for backend services. Each app or service is independent so they \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"can\"), \" use a different framework or language. One service \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"can be\"), \" Ruby+Rails and another use Elixir+Phoenix. But in practice most companies should and will avoid this, it doesn't make sense to use any and every language or framework! No different here. Standardizing on few languages/frameworks makes total sense.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Your \", \"[developers]\", \" were so preoccupied with whether or not they could, they didn\\u2019t stop to think if they should.\")), mdx(\"p\", null, \"Just because it \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"can be done\"), \", does not mean it \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"should or needs\"), \" to be done. Most if not all of your apps should use a common set of frameworks and libraries. But realize that this possibility of using a different framework without high development costs and effort actually unlocks benefits, such as easy migration and experimentation. I find that to be super cool! Let me paint those scenarios.\"), mdx(\"h3\", null, \"Migrate\"), mdx(\"p\", null, \"At some point in every company's life, there comes a point where the decision to use Technology X that was made Y number of years ago no longer holds up. The maintainers do not see an easy way to move off of it, they're stuck. Being able to break free of and avoid \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://en.wikipedia.org/wiki/Vendor_lock-in#Technology_lock-in\"\n  }), \"technological lock-in\"), \" is yet another \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"major benefit\"), \" of microservices in the browser. Using a front-end microservices architecture, you can begin migrating parts of the application to newer technologies and frameworks as each team or product is ready and able (the performance implications will be discussed below).\"), mdx(\"h3\", null, \"Experimentation\"), mdx(\"p\", null, \"Maybe Technology X is not quite that old, but your developers see new trends on the horizon and want to get ahead of the curve. Or maybe a webapp has grown bloated and is a performance bottleneck and you would like to try out a newer, faster framework (something like \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/sveltejs/svelte\"\n  }), \"Svelte\"), \" maybe). This sort of experimentation could allow products, user experiences, and DX to improve as technologies evolve and advance. These upgrades shouldn't require months and years!\"), mdx(\"h2\", null, \"Multiple React roots\"), mdx(\"blockquote\", {\n    className: \"twitter-tweet\",\n    \"data-conversation\": \"none\",\n    \"data-lang\": \"en\"\n  }, mdx(\"p\", {\n    lang: \"und\",\n    dir: \"ltr\"\n  }, mdx(\"a\", {\n    href: \"https://t.co/4VCG8cFxjc\",\n    \"aria-label\": \"Meme: Multiple React roots on the page. Is this microfrontends?\"\n  }, \"pic.twitter.com/4VCG8cFxjc\")), \"\\u2014 Dan Abramov (@dan_abramov) \", mdx(\"a\", {\n    href: \"https://twitter.com/dan_abramov/status/1139157092420505600?ref_src=twsrc%5Etfw\"\n  }, \"June 13, 2019\")), mdx(\"p\", null, \"The answer to Dan's question here is \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"yes\"), \". This can be considered \\\"microfrontends\\\" as each root can be owned by a single team. Though Dan later points out that this all is still part of the same CD pipeline and so each team is at the mercy of that process. Significant effort and investment would need to be spent to optimize this build system. But like backend microservices, microservices in the browser can enable \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"independent deployments\"), \" for front-end applications. Each team can have control over this, scaling to however fast or slow that needs to be for them. I don't think you could achieve that with multiple React roots.\"), mdx(\"h2\", null, \"50MB of JavaScript\"), mdx(\"blockquote\", {\n    className: \"twitter-tweet\",\n    \"data-lang\": \"en\"\n  }, mdx(\"p\", {\n    lang: \"en\",\n    dir: \"ltr\"\n  }, \"Someone let me perf. profile a site using \\\"microfrontends\\\". \", mdx(\"br\", null), mdx(\"br\", null), \"Memebait related: \", mdx(\"a\", {\n    href: \"https://t.co/LMldrx14Ui\",\n    \"aria-label\": \"Meme: 50 MB of JavaScript. Is this microfrontends?\"\n  }, \"pic.twitter.com/LMldrx14Ui\")), \"\\u2014 Sean Larkin (\\u5ED6\\u8096\\u6069) (@TheLarkInn) \", mdx(\"a\", {\n    href: \"https://twitter.com/TheLarkInn/status/1139281821810618369?ref_src=twsrc%5Etfw\"\n  }, \"June 13, 2019\")), mdx(\"p\", null, \"I have to ask: \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"is application bloat a unique characteristic of microfrontends?\"), \" I know of many frontend applications that are extremely heavy that are \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"not microfrontends\"), \", which is mostly due to misconfiguration of tooling or extra package code. So is this criticism that implicitly claims that microservices are bloated by default, valid?\"), mdx(\"p\", null, \"The underlying assumption here is that microfrontends disregard performance in favor of DX. Additionally, it's true that 2 is greater than 1; shipping multiple framework runtimes without prudence and care is going to be bad. But I'd argue though that that bad performance comes down to implementation, not architecture.\"), mdx(\"p\", null, \"There are many solutions to the perf problem; none of them impossible with microservices in the browser. One interesting option is to leverage native ES modules (current spec) along with \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/WICG/import-maps\"\n  }), \"import maps\"), \" (proposed spec). This enables your JavaScript imports to be cleanly resolved \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"in the browser\"), \". No longer bundle libraries into your build, load them once and cache in the browser. Share these dependencies across all of your apps. Performance does not have to be sacrificed for microfrontends' sake. \"), mdx(\"aside\", null, \"If these features appeal to you and your organization, check out \", mdx(\"a\", {\n    href: \"https://single-spa.js.org/\"\n  }, \"Single-spa\"), \" and it's \", mdx(\"a\", {\n    href: \"https://single-spa.js.org/docs/faq.html#is-there-a-recommended-setup\"\n  }, \"recommended setup\"), \" that leverages the aforementioned import-maps. \", mdx(\"small\", {\n    style: {\n      \"marginBottom\": \"0\"\n    }\n  }, \"Disclaimer: I'm a contributor to Single-spa.\")), mdx(\"h1\", null, \"Give it a little bit of time, and maybe a try\"), mdx(\"blockquote\", {\n    className: \"twitter-tweet\"\n  }, mdx(\"p\", {\n    lang: \"en\",\n    dir: \"ltr\"\n  }, \"Back end devs: Front end isn't real engineering.\", mdx(\"br\", null), mdx(\"br\", null), \"Front end devs: *Bring engineering principles to front end*\", mdx(\"br\", null), mdx(\"br\", null), \"Back end devs: Front end is too complicated.\"), \"\\u2014 Mark Dalgleish (@markdalgleish) \", mdx(\"a\", {\n    href: \"https://twitter.com/markdalgleish/status/1150488911744917505?ref_src=twsrc%5Etfw\"\n  }, \"July 14, 2019\")), mdx(\"p\", null, \"Give an emerging pattern like microservices in the browser a chance. Don't buck against it just because it isn't the way you've done things, and let go of your bad assumptions.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Bad Assumptions about Microfrontends","date":"Aug 09, 2019","tags":["javascript"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/bad-assumptions-about-microfrontends/"}}}