{
    "componentChunkName": "component---src-templates-post-js",
    "path": "/react-component-file-structure-proposal/",
    "result": {"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"React component file structure proposal\",\n  \"date\": \"2022-08-12T00:00:00.000Z\",\n  \"tags\": [\"react\", \"typescript\", \"testing\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"This is an attempt at a proposal for organizing a React component file structure based on the needs and current patterns at my current place of employment. I'm sharing this first on my blog to get some external feedback, but I also think its a good discussion point in general. For context, our tech stack uses the following: TypeScript, React, Jest, and Storybook. The idea is that this code will be generated as part of a code generator.\"), mdx(\"p\", null, \"The pattern has the following file structure and naming:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"{CompName}/\\n\\u251C\\u2500\\u2500index.tsx\\n\\u251C\\u2500\\u2500use{CompName}Logic.ts\\n\\u251C\\u2500\\u2500use{CompName}Logic.test.tsx\\n\\u251C\\u2500\\u2500{CompName}Component.tsx\\n\\u2514\\u2500\\u2500{CompName}Component.stories.tsx\\n\")), mdx(\"h2\", null, \"Reasoning\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"index.tsx helps make importing simple, eg. \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"import { CompName } from './CompName'\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"em\", {\n    parentName: \"li\"\n  }, \"'use{CompName}Logic'\"), \" encourages colocating business logic with its unit test (Jest)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"em\", {\n    parentName: \"li\"\n  }, \"'{CompName}Component'\"), \" encourages colocating UI-related code with its corresponding story (Storybook)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Generating a component as part of developer onboarding experience would be a great primer for how these should work and establish best practices\")), mdx(\"h2\", null, \"File contents\"), mdx(\"p\", null, \"To better illustrate the need for such a pattern, I've filled in the contents of the files below.\"), mdx(\"h3\", null, \"index.tsx\"), mdx(\"p\", null, \"All this file does is export the hooked component, and creates a type for props.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"import { CompNameComponent } from './CompNameComponent'\\nimport { useCompNameLogic } from './useCompNameLogic'\\n\\n// NOTE: having this into index.ts creates a circular dependency.\\n// I'm unsure whether this is okay given that this is just a Type, which is not included in compiled code...\\n// but makes for a better match for condensed file structure (see below). Alternatively this could be\\n// colocated in use{CompName}Logic file.\\nexport type CompNameProps = ReturnType<typeof useCompNameLogic>\\n\\nexport const CompName = withHookHoc(CompNameComponent, useCompNameLogic)\\n\")), mdx(\"h3\", null, \"use{CompName}Logic.ts\"), mdx(\"p\", null, \"This file should only contain business logicl. Its return value will be passed as props to the component.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"import React from 'react'\\n\\nexport const useCompNameLogic = () => {\\n  return {}\\n}\\n\")), mdx(\"h3\", null, \"use{CompName}Logic.test.ts\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"import React from 'react'\\nimport { renderHook } from '@testing-library/react-hooks'\\nimport { useCompNameLogic } from './useCompNameLogic'\\nimport type { CompNameProps } from '.'\\n\\ndescribe(useCompNameLogic, () => {\\n  const mockProps: CompNameProps = {}\\n\\n  const render = (testProps: Partial<CompNameProps> = {}) => {\\n    return renderHook(useCompNameLogic, {\\n      initialProps: {\\n        ...mockProps,\\n        ...testProps,\\n      },\\n    })\\n  }\\n\\n  it('returns valid default props', async () => {\\n    const { result } = render()\\n\\n    expect(result.current).toBeDefined() // TODO: have a better default test...\\n  })\\n})\\n\")), mdx(\"p\", null, \"Additional ideas:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"optionally allow generating Apollo MockedProvider code & wrapper\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"optionally allow generating react-router MemoryRouter code & wrapper\")), mdx(\"h3\", null, \"{CompName}Component.tsx\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"import React from 'react'\\nimport { withHookHoc } from '@jupiterone/web-apps-core'\\nimport { makeUseStyles } from '@jupiterone/web-juno'\\nimport type { CompNameProps } from '.'\\n\\nconst useStyles = makeUseStyles((theme) => {\\n  return {}\\n})\\n\\nexport const CompNameComponent = (props: CompNameProps) => {\\n  const styles = useStyles()\\n  return <></>\\n}\\n\")), mdx(\"h3\", null, \"{CompName}Component.stories.tsx\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"import React from 'react'\\nimport { storybookTemplate } from '@jupiterone/web-apps-core'\\nimport { CompNameComponent } from './CompNameComponent'\\nimport type { CompNameProps } from '.'\\n\\n// TODO: update storybookTemplate to accept typings\\nconst { template, meta } = storybookTemplate<CompNameProps>({\\n  title: 'CompName',\\n  component: CompNameComponent,\\n})\\n\\nexport default meta\\nexport const Default = template({})\\n\")), mdx(\"h2\", null, \"Extra credit: condensed file structure\"), mdx(\"p\", null, \"If, say, you have a very simple component that doesn't need 5 files... just reduce it down to the one index file but retaining the file names for tests.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"{CompName}/\\n\\u251C\\u2500\\u2500index.tsx\\n\\u251C\\u2500\\u2500use{CompName}Logic.test.tsx\\n\\u2514\\u2500\\u2500{CompName}Component.stories.tsx\\n\")), mdx(\"h3\", null, \"index.tsx\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"import React from 'react'\\nimport React from 'react'\\nimport { withHookHoc } from '@jupiterone/web-apps-core'\\nimport { makeUseStyles } from '@jupiterone/web-juno'\\n\\n/* --- Logic --- */\\nexport const useCompNameLogic = () => {\\n  return {}\\n}\\n\\nexport type CompNameProps = ReturnType<typeof useCompNameLogic>\\n\\n/* --- Component --- */\\nconst useStyles = makeUseStyles((theme) => {\\n  return {}\\n})\\n\\nexport const CompNameComponent = (props: CompNameProps) => {\\n  const styles = useStyles()\\n  return <></>\\n}\\n\\nexport const CompName = withHookHoc(CompNameComponent, useCompNameLogic)\\n\")), mdx(\"h3\", null, \"use{CompName}Logic.test.ts\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"import React from 'react'\\nimport { renderHook } from '@testing-library/react-hooks'\\nimport { useCompNameLogic } from '.'\\nimport type { CompNameProps } from '.'\\n\\ndescribe(useCompNameLogic, () => {\\n  const mockProps: CompNameProps = {}\\n\\n  const render = (testProps: Partial<CompNameProps> = {}) => {\\n    return renderHook(useCompNameLogic, {\\n      initialProps: {\\n        ...mockProps,\\n        ...testProps,\\n      },\\n    })\\n  }\\n\\n  it('returns valid default props', async () => {\\n    const { result } = render()\\n\\n    expect(result.current).toBeDefined()\\n  })\\n})\\n\")), mdx(\"h3\", null, \"{CompName}Component.stories.tsx\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"import React from 'react'\\nimport { storybookTemplate } from '@jupiterone/web-apps-core'\\nimport { CompNameComponent } from '.'\\nimport type { CompNameProps } from '.'\\n\\n// TODO: update storybookTemplate to accept typings\\nconst { template, meta } = storybookTemplate<CompNameProps>({\\n  title: 'CompName',\\n  component: CompNameComponent,\\n})\\n\\nexport default meta\\nexport const Default = template({})\\n\")), mdx(\"p\", null, \"What do you think? Would you use a codebase structured like this?\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"React component file structure proposal","date":"12 Aug 22","tags":["react","typescript","testing"]}}},"pageContext":{"slug":"/react-component-file-structure-proposal/"}},
    "staticQueryHashes": ["3649515864"]}