{"data":{"mdx":{"code":{"body":"function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nconst layoutProps = {};\nreturn class MDXContent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.layout = null;\n  }\n\n  render() {\n    const _this$props = this.props,\n          {\n      components\n    } = _this$props,\n          props = _objectWithoutProperties(_this$props, [\"components\"]);\n\n    return React.createElement(MDXTag, {\n      name: \"wrapper\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `There've been some surprisingly incorrect assumptions made about \"microfrontends\" since it became a buzzword. Microservices in the browser (I prefer this term over microfrontends) are a totally new paradigm but these bad takes seem to have quite a bit of reach. It is kind of amazing, and I'll tackle some of these in this post. `), React.createElement(MDXTag, {\n      name: \"h2\",\n      components: components\n    }, `Multiple frameworks`), React.createElement(MDXTag, {\n      name: \"blockquote\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"p\",\n      components: components,\n      parentName: \"blockquote\"\n    }, `The idea really is that you might build a React app and I build a Vue app and we'll slap 'em together on the same page. I definitely come from an era where we laughed-then-winced when we found sites that used multiple versions of jQuery on the same page... We winced because that was a bucket full of JavaScript, mostly duplicated for no reason, causing bugs and slowing down the page. This doesn't seem all that much different.`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components,\n      parentName: \"blockquote\"\n    }, React.createElement(MDXTag, {\n      name: \"em\",\n      components: components,\n      parentName: \"p\"\n    }, `Chris Coyier, `, React.createElement(MDXTag, {\n      name: \"a\",\n      components: components,\n      parentName: \"em\",\n      props: {\n        \"href\": \"https://css-tricks.com/micro-frontends/\"\n      }\n    }, `https://css-tricks.com/micro-frontends/`)))), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `This is actually a `, React.createElement(MDXTag, {\n      name: \"strong\",\n      components: components,\n      parentName: \"p\"\n    }, `huge`), ` mischaracterization. Think about this for backend services. Each app or service is independent so they `, React.createElement(MDXTag, {\n      name: \"em\",\n      components: components,\n      parentName: \"p\"\n    }, `can`), ` use a different framework or language. One service `, React.createElement(MDXTag, {\n      name: \"em\",\n      components: components,\n      parentName: \"p\"\n    }, `can be`), ` Ruby+Rails and another use Elixir+Phoenix. But in practice most companies will avoid this, it doesn't make sense to allow any and every language or framework. No different here. Standardizing on few languages/frameworks makes total sense!`), React.createElement(MDXTag, {\n      name: \"blockquote\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"p\",\n      components: components,\n      parentName: \"blockquote\"\n    }, `Your `, `[developers]`, ` were so preoccupied with whether or not they could, they didnâ€™t stop to think if they should.`)), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `Just because it `, React.createElement(MDXTag, {\n      name: \"em\",\n      components: components,\n      parentName: \"p\"\n    }, `can be done`), `, does not mean it `, React.createElement(MDXTag, {\n      name: \"em\",\n      components: components,\n      parentName: \"p\"\n    }, `should or needs`), ` to be done. Most if not all of your apps should use the same framework and libraries. But realize that this possibility of using a different framework without high development costs and effort actually unlocks benefits! Namely, to migrate and experiment. I find that to be super cool! Let me p those scenarios.`), React.createElement(MDXTag, {\n      name: \"h3\",\n      components: components\n    }, `Migrate`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `At every point in a company's life, they reach a point where the decision to use Technology X or Y  that was made 5+ years ago no longer holds up. The maintainers do not see an easy way to move off of it. Using a front-end microservices architecture, you can begin migrating parts of the application to newer technologies and frameworks as each team or product is ready and able (the performance implications will be discussed below).`), React.createElement(MDXTag, {\n      name: \"h3\",\n      components: components\n    }, `Experimentation`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `Maybe Framework X is not quite that old, but your developers see new trends on the horizon. Or maybe an application has grown bloated and is a performance bottleneck and you would like to try out a newer, faster framework (like `, React.createElement(MDXTag, {\n      name: \"a\",\n      components: components,\n      parentName: \"p\",\n      props: {\n        \"href\": \"https://github.com/sveltejs/svelte\"\n      }\n    }, `Svelte`), `). This sort of experimentation could allow products, user experiences, and DX to improve as technologies evolve and advance. Change does not always require months and years!`), React.createElement(MDXTag, {\n      name: \"h2\",\n      components: components\n    }, `Multiple React roots`), React.createElement(\"blockquote\", {\n      className: \"twitter-tweet\",\n      \"data-conversation\": \"none\",\n      \"data-lang\": \"en\"\n    }, React.createElement(\"p\", {\n      lang: \"und\",\n      dir: \"ltr\"\n    }, React.createElement(\"a\", {\n      href: \"https://t.co/4VCG8cFxjc\"\n    }, \"pic.twitter.com/4VCG8cFxjc\")), \"\\u2014 Dan Abramov (@dan_abramov) \", React.createElement(\"a\", {\n      href: \"https://twitter.com/dan_abramov/status/1139157092420505600?ref_src=twsrc%5Etfw\"\n    }, \"June 13, 2019\")), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `The answer to Dan's question here is `, React.createElement(MDXTag, {\n      name: \"strong\",\n      components: components,\n      parentName: \"p\"\n    }, `yes`), `. This can definitely be considered \"microfrontends\" as each top-level app can be independent. But also this is totally dependent on a single framework, React. What happens if React is no longer the technology to use due to performance or licensing or age, or anything really? Being able to break free of and avoid `, React.createElement(MDXTag, {\n      name: \"a\",\n      components: components,\n      parentName: \"p\",\n      props: {\n        \"href\": \"https://en.wikipedia.org/wiki/Vendor_lock-in#Technology_lock-in\"\n      }\n    }, `technological lock-in`), ` another `, React.createElement(MDXTag, {\n      name: \"strong\",\n      components: components,\n      parentName: \"p\"\n    }, `major benefit`), ` of microservices in the browser.`), React.createElement(MDXTag, {\n      name: \"h2\",\n      components: components\n    }, `50MB of JavaScript`), React.createElement(\"blockquote\", {\n      className: \"twitter-tweet\",\n      \"data-lang\": \"en\"\n    }, React.createElement(\"p\", {\n      lang: \"en\",\n      dir: \"ltr\"\n    }, \"Someone let me perf. profile a site using \\\"microfrontends\\\". \", React.createElement(\"br\", null), React.createElement(\"br\", null), \"Memebait related: \", React.createElement(\"a\", {\n      href: \"https://t.co/LMldrx14Ui\"\n    }, \"pic.twitter.com/LMldrx14Ui\")), \"\\u2014 Sean Larkin (\\u5ED6\\u8096\\u6069) (@TheLarkInn) \", React.createElement(\"a\", {\n      href: \"https://twitter.com/TheLarkInn/status/1139281821810618369?ref_src=twsrc%5Etfw\"\n    }, \"June 13, 2019\")), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `I have to ask \"is a bloated app a unique characteristic of microfrontends?\" I know of many frontend applications that are extremely heavy that are `, React.createElement(MDXTag, {\n      name: \"em\",\n      components: components,\n      parentName: \"p\"\n    }, `not microfrontends`), `. Much of this is due to misconfiguration of tooling or extra package code. So what gives with this criticism that implicitly claims that microservices are bloated by default?`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `It's true that 1 is greater than 2. Shipping two runtimes can be bad. I'd argue though that bad performance comes down to implementation, not architecture. There are many solutions to this problem, none of them impossible with microservices in the browser.`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `One interesting and future-facing solution is a proposed browser spec called `, React.createElement(MDXTag, {\n      name: \"a\",\n      components: components,\n      parentName: \"p\",\n      props: {\n        \"href\": \"https://github.com/WICG/import-maps\"\n      }\n    }, `import maps`), `. It enables your JavaScript imports to be resolved `, React.createElement(MDXTag, {\n      name: \"em\",\n      components: components,\n      parentName: \"p\"\n    }, `in the browser`), `. You would no longer need to bundle libraries into your build, and with the correct bundler configuration these dependencies can be shared across all of your apps. The file from which you `, React.createElement(MDXTag, {\n      name: \"inlineCode\",\n      components: components,\n      parentName: \"p\"\n    }, `import React from 'react`), ` or `, React.createElement(MDXTag, {\n      name: \"inlineCode\",\n      components: components,\n      parentName: \"p\"\n    }, `import _ from lodash`), ` is completely separate from your build, downloaded once, and cached! Performance does not have to be sacrificed for microfrontends' sake. `), React.createElement(Aside, null, \"If the above sounds interesting to you, check out \", React.createElement(\"a\", {\n      href: \"\"\n    }, \"SystemJS\"), \" which is a polyfill for the spec.\"));\n  }\n\n}"},"frontmatter":{"title":"Bad Assumptions about Microfrontends","date":"Jul 20, 2019","tags":["javascript"]}}},"pageContext":{"slug":"/bad-assumptions-about-microfrontends/"}}