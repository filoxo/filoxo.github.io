{"data":{"mdx":{"__typename":"Mdx","html":"<div><p>I&#x27;ve been thinking about the complexity required for making accessible buttons, or rather interactive elements. One pattern that has bothered me a lot recently is what I call the &#x27;non-button button&#x27;. This is an interactive element that is used like (and sometimes even looks like) a <code>button</code> but for whatever reason it is not an HTML <code>button</code> element. This poses a huge problem for accessibility and I want to dive into <em>why</em> that is. </p><p>Let&#x27;s begin with an example of a non-button button:</p><pre><code class=\"language-html\">&lt;div class=&quot;myBtn&quot;&gt;Do the thing&lt;/div&gt;\n\n&lt;script&gt;\nconst handleClick = (e) =&gt; {\n  console.log(&#x27;myBtn clicked&#x27;)\n}\nconst myBtn = document.querySelector(&#x27;.myBtn&#x27;)\nmyBtn.addEventListener(&#x27;click&#x27;, handleClick)\n&lt;/script&gt;\n</code></pre><small>Don&#x27;t get hung up on how the event be being bound; the principles would be the same if you were using jQuery, React, etc.</small><p>The main reason I&#x27;ve found for using this pattern is for when the clickable element absolutely requires block level elements. The HTML <code>button</code> is an inline element and cannot contain block level elements. And even then, I&#x27;ve worked around this requirement by using <a href=\"https://davidwalsh.name/event-delegate\">Event Delegation</a>. But for comparison and teaching, I&#x27;ll go over what it would take to reach feature parity with a button.</p><h3>Keyboard pt 1: Focus</h3><p>One problem with this non-button is that it cannot receive focus, and therefore cannot be navigated to with a keyboard. This means that there is no way to trigger it without using a mouse and clicking on the element. The HTML <code>button</code> however does allow focus so we&#x27;ll need to achieve the same. This can be done with the <code>tabindex</code> attribute. Setting this attribute to <code>0</code> simply adds the element to the tab order.  </p><pre><code class=\"language-html\">&lt;div class=&quot;myBtn&quot; tabindex=&quot;0&quot;&gt;Do the thing&lt;/div&gt;\n</code></pre><p>Now you can tab to this element with your keyboard, and see the keyboard outline when focused on it. HTML buttons are focusable by default. </p><h3>Keyboard pt 2: Events</h3><p>Focusing on an element is only half of the keyboard navigation story. The element should also respond to keyboard <code>Enter</code> or <code>Space</code> events to trigger the same <code>&#x27;click&#x27;</code> action. This is a feature that HTML <code>buttons</code> can give you for free.</p><pre><code class=\"language-html\">&lt;div class=&quot;myBtn&quot; tabindex=&quot;0&quot;&gt;Do the thing&lt;/div&gt;\n\n&lt;script&gt;\nconst handleClick = (e) =&gt; {\n  console.log(&#x27;myBtn clicked&#x27;)\n}\nconst handleKeyboardClick = (fn) =&gt; {\n  return (e) =&gt; {\n    if(e.key === &#x27;Enter&#x27; || e.key === &#x27; &#x27;) {\n      return fn(e)\n    }\n  }\n}\nconst myBtn = document.querySelector(&#x27;.myBtn&#x27;)\nmyBtn.addEventListener(&#x27;click&#x27;, handleClick)\nmyBtn.addEventListener(&#x27;keydown&#x27;, handleKeyboardClick(handleClick))\n&lt;/script&gt;\n</code></pre><p>Take a look at the <code>handleKeyboardClick</code> function above. This is a small <a href=\"https://www.sitepoint.com/currying-in-functional-javascript/\">curried function</a> that accepts a function as a parameter (<code>fn</code>), and returns a function that will guard executing <code>fn</code> only if the event key is <code>&#x27;Enter&#x27;</code> or <code>&#x27; &#x27;</code> (Space). This helper can be reused to wrap any additional click handlers that we may need also need to bind later.</p><p>I&#x27;d like to note that this additional event binding isn&#x27;t necessary if using an HTML button. It will trigger click handlers when Enter or Space is pressed. </p><h3>Semantics</h3><p>Now that we can reach the element with a keyboard, let&#x27;s switch to using another assistive device: a screenreader. A screenreader allows a non-visual user to be able to navigate and read the page content. So what happens when such a user navigates to our non-button? </p><p><img src=\"dothething-div-sr.png\" alt=\"This screenshot shows that when focused on the non-button element, the screenreader only identifies only inner text of &quot;Do the thing&quot;.\"/></p><p>Let&#x27;s compare this with an actual button, which I&#x27;ve added underneath the non-button button. </p><p><img src=\"dothething-btn-sr.png\" alt=\"In contrast, this screenshot shows that when the button is focused the screenreader identifies &quot;Do the thing, button&quot;.\"/></p><p>It shouldn&#x27;t be any surprise to see that a div semantically doesn&#x27;t represent anything. It should also be noted that the CSS class name that we&#x27;re using to select this element offers nothing for assistive tech to identify. Also not surprising is that the HTML button is identfied as a button. </p><p>We can fix this by adding the correct aria-role attribute. If you haven&#x27;t yet read through the <a class=\"link\" href=\"https://www.w3.org/TR/wai-aria-practices-1.1/\">WAI-ARIA Authoring Practices</a> it is time you did. It outlines the following:</p><ul><li>If this control is a <em>push button</em>, it needs a <code>role=&quot;button&quot;</code> to designate it as an interactive button</li><li>if this control is a <em>toggle button</em>, it needs <code>role=&quot;button&quot;</code> and <code>aria-pressed</code> attributes, and <code>aria-pressed</code> is updated to reflect the current state of the control (eg. <code>aria-pressed=&quot;true&quot;</code>)</li></ul><pre><code class=\"language-html\">&lt;div class=&quot;myBtn&quot; tabindex=&quot;0&quot; role=&quot;button&quot;&gt;Do the thing&lt;/div&gt;\n&lt;!--- OR ---&gt;\n&lt;div class=&quot;myBtn&quot; tabindex=&quot;0&quot; role=&quot;button&quot; aria-pressed=&quot;false&quot;&gt;Do the thing&lt;/div&gt;\n\n&lt;script&gt;\nconst handleClick = (e) =&gt; {\n  console.log(&#x27;myBtn clicked&#x27;)\n  // Update aria-pressed for toggle buttons\n  const pressed = e.target.getAttribute(&#x27;aria-pressed&#x27;) === &#x27;true&#x27;\n  e.target.setAttribute(&#x27;aria-pressed&#x27;, pressed);\n}\nconst handleKeyboardClick = (fn) =&gt; {\n  return (e) =&gt; {\n    if(e.key === &#x27;Enter&#x27; || e.key === &#x27; &#x27;) {\n      return fn(e)\n    }\n  }\n}\nconst myBtn = document.querySelector(&#x27;.myBtn&#x27;)\nmyBtn.addEventListener(&#x27;click&#x27;, handleClick)\nmyBtn.addEventListener(&#x27;keydown&#x27;, handleKeyboardClick(handleClick))\n&lt;/script&gt;\n</code></pre></div>","frontmatter":{"title":"Accessible Buttons","date":"Oct 01, 2018","tags":["javascript","development"]}},"markdownRemark":null},"pageContext":{"slug":"/accessible-buttons/"}}