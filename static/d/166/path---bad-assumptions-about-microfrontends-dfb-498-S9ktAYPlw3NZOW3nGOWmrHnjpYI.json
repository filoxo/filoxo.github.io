{"data":{"mdx":{"code":{"body":"function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nconst layoutProps = {};\nreturn class MDXContent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.layout = null;\n  }\n\n  render() {\n    const _this$props = this.props,\n          {\n      components\n    } = _this$props,\n          props = _objectWithoutProperties(_this$props, [\"components\"]);\n\n    return React.createElement(MDXTag, {\n      name: \"wrapper\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `I find it kind of amazing how many bad assumptions are being made about microfrontends. Like, really, just stop for a minute. Think a little harder. I get that microservices in the browser (I prefer this term over microfrontends) are a totally new paradigm but don't make totally bad assumptions. I'll tackle some of these in this post. `), React.createElement(MDXTag, {\n      name: \"h2\",\n      components: components\n    }, `Multiple frameworks`), React.createElement(MDXTag, {\n      name: \"blockquote\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"p\",\n      components: components,\n      parentName: \"blockquote\"\n    }, `The idea really is that you might build a React app and I build a Vue app and we'll slap 'em together on the same page. I definitely come from an era where we laughed-then-winced when we found sites that used multiple versions of jQuery on the same page... We winced because that was a bucket full of JavaScript, mostly duplicated for no reason, causing bugs and slowing down the page. This doesn't seem all that much different.`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components,\n      parentName: \"blockquote\"\n    }, React.createElement(MDXTag, {\n      name: \"em\",\n      components: components,\n      parentName: \"p\"\n    }, `Chris Coyier, `, React.createElement(MDXTag, {\n      name: \"a\",\n      components: components,\n      parentName: \"em\",\n      props: {\n        \"href\": \"https://css-tricks.com/micro-frontends/\"\n      }\n    }, `https://css-tricks.com/micro-frontends/`)))), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `This is actually a `, React.createElement(MDXTag, {\n      name: \"strong\",\n      components: components,\n      parentName: \"p\"\n    }, `huge`), ` mischaracterization. Think about this for backend services. Each app is isolated, it `, React.createElement(MDXTag, {\n      name: \"em\",\n      components: components,\n      parentName: \"p\"\n    }, `can`), ` use a different framework or language so one service `, React.createElement(MDXTag, {\n      name: \"em\",\n      components: components,\n      parentName: \"p\"\n    }, `can be`), ` Ruby+Rails and another use Elixir+Phoenix. But in practice most companies will avoid this, it doesn't make sense to have every app be a different language or framework. No different here. Keeping a standard language or set of languages makes total sense.`), React.createElement(MDXTag, {\n      name: \"blockquote\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"p\",\n      components: components,\n      parentName: \"blockquote\"\n    }, `Your `, `[developers]`, ` were so preoccupied with whether or not they could, they didnâ€™t stop to think if they should.`)), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `Just because it `, React.createElement(MDXTag, {\n      name: \"strong\",\n      components: components,\n      parentName: \"p\"\n    }, `can be done`), `, does not mean it `, React.createElement(MDXTag, {\n      name: \"strong\",\n      components: components,\n      parentName: \"p\"\n    }, `needs to be done`), `. Most if not all of your apps should use the same framework and libraries. But this possibility of using a different framework without high costs unlocks benefits to migrate and experiment. I find that to be super cool! Let me paint those scenarios.`), React.createElement(\"small\", null, React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `In Chris' article, he makes reference to a `, React.createElement(MDXTag, {\n      name: \"a\",\n      components: components,\n      parentName: \"p\",\n      props: {\n        \"href\": \"https://martinfowler.com/articles/micro-frontends.html#Run-timeIntegrationViaIframes\"\n      }\n    }, `recommendation to use `, React.createElement(MDXTag, {\n      name: \"inlineCode\",\n      components: components,\n      parentName: \"a\"\n    }, `<iframe>s`)), `. If I may be so bold, there is no reason this should be done in modern web development. `, React.createElement(MDXTag, {\n      name: \"strong\",\n      components: components,\n      parentName: \"p\"\n    }, `Never ever do this`), `.`)), React.createElement(MDXTag, {\n      name: \"h3\",\n      components: components\n    }, `Migrate`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `This is typical of almost every company. Someone made a decision to use a technology 5+ years ago, company is still using it and does not see an easy way to move of of it. Using front-end microservices you can begin migrating parts of the application to newer technologies and frameworks (the performance implications will be discussed below) as each team or product is ready.`), React.createElement(MDXTag, {\n      name: \"h3\",\n      components: components\n    }, `Experimentation`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `At some point, the current framework you use may become outdated. Or maybe an application has grown and is a performance bottleneck and you would like to try out a newer, faster framework (like `, React.createElement(MDXTag, {\n      name: \"a\",\n      components: components,\n      parentName: \"p\",\n      props: {\n        \"href\": \"https://github.com/sveltejs/svelte\"\n      }\n    }, `Svelte`), `). Allowing for this sort of experimentation could actually be much better for your users in the long run as technologies evolve.`), React.createElement(MDXTag, {\n      name: \"h2\",\n      components: components\n    }, `Multiple React roots`), React.createElement(\"blockquote\", {\n      className: \"twitter-tweet\",\n      \"data-conversation\": \"none\",\n      \"data-lang\": \"en\"\n    }, React.createElement(\"p\", {\n      lang: \"und\",\n      dir: \"ltr\"\n    }, React.createElement(\"a\", {\n      href: \"https://t.co/4VCG8cFxjc\"\n    }, \"pic.twitter.com/4VCG8cFxjc\")), \"\\u2014 Dan Abramov (@dan_abramov) \", React.createElement(\"a\", {\n      href: \"https://twitter.com/dan_abramov/status/1139157092420505600?ref_src=twsrc%5Etfw\"\n    }, \"June 13, 2019\")), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `The answer to this is `, React.createElement(MDXTag, {\n      name: \"strong\",\n      components: components,\n      parentName: \"p\"\n    }, `yes`), `. This can definitely be considered a microfrontend as each top-level app can be \"isolated\". But realize, this is totally dependent on a single technology. What happens if React is no longer the technology to use (due to performance or licensing or age, or anything really)? Being able to avoid (technological lock-in)`, `[https://en.wikipedia.org/wiki/Vendor_lock-in#Technology_lock-in]`, ` is one major benefit of microservices in the browser.`), React.createElement(MDXTag, {\n      name: \"h2\",\n      components: components\n    }, `50Mb of javascript`), React.createElement(\"blockquote\", {\n      className: \"twitter-tweet\",\n      \"data-lang\": \"en\"\n    }, React.createElement(\"p\", {\n      lang: \"en\",\n      dir: \"ltr\"\n    }, \"Someone let me perf. profile a site using \\\"microfrontends\\\". \", React.createElement(\"br\", null), React.createElement(\"br\", null), \"Memebait related: \", React.createElement(\"a\", {\n      href: \"https://t.co/LMldrx14Ui\"\n    }, \"pic.twitter.com/LMldrx14Ui\")), \"\\u2014 Sean Larkin (\\u5ED6\\u8096\\u6069) (@TheLarkInn) \", React.createElement(\"a\", {\n      href: \"https://twitter.com/TheLarkInn/status/1139281821810618369?ref_src=twsrc%5Etfw\"\n    }, \"June 13, 2019\")), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `I have to ask \"Is a bloated app a unique characteristic of microfrontends?\" I know of many frontend applications that are extremely heavy that are not microfrontends. So what gives? I think this criticism conflates performance and library size issues. `));\n  }\n\n}"},"frontmatter":{"title":"Bad Assumptions about Microfrontends","date":"Jul 20, 2019","tags":["javascript"]}}},"pageContext":{"slug":"/bad-assumptions-about-microfrontends/"}}