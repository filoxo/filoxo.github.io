{"data":{"mdx":{"code":{"body":"function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nconst layoutProps = {};\nreturn class MDXContent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.layout = null;\n  }\n\n  render() {\n    const _this$props = this.props,\n          {\n      components\n    } = _this$props,\n          props = _objectWithoutProperties(_this$props, [\"components\"]);\n\n    return React.createElement(MDXTag, {\n      name: \"wrapper\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `It's 2019 and I still see new code being written which uses non-interactive elements as buttons. Here's some quick example code:`), React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-html\"\n      }\n    }, `<div class=\"myBtn\">Do the thing</div>\n\n<script>\nconst handleClick = (e) => {\n  console.log('myBtn clicked')\n}\nconst myBtn = document.querySelector('.myBtn')\nmyBtn.addEventListener('click', handleClick)\n</script>\n`)), React.createElement(\"small\", null, \"Don't get hung up on how the event is being bound; the principles would be the same if you were using jQuery, React, etc.\"), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `Let's rehash why this is a problem. `), React.createElement(MDXTag, {\n      name: \"h3\",\n      components: components\n    }, `Keyboard Accessibility pt 1: Focus`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `One problem with this non-button is that it cannot receive focus, and therefore cannot be navigated to with a keyboard. This means that there is no way to trigger it without using a mouse and clicking on the element. This can be done with the `, React.createElement(MDXTag, {\n      name: \"inlineCode\",\n      components: components,\n      parentName: \"p\"\n    }, `tabindex`), ` attribute. Setting this attribute to `, React.createElement(MDXTag, {\n      name: \"inlineCode\",\n      components: components,\n      parentName: \"p\"\n    }, `0`), ` simply adds the element to the tab order.  `), React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-html\"\n      }\n    }, `<div class=\"myBtn\" tabindex=\"0\">Do the thing</div>\n`)), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `Now you can tab to this element with your keyboard, and see the keyboard outline when focused on it. `), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"strong\",\n      components: components,\n      parentName: \"p\"\n    }, `HTML `, React.createElement(MDXTag, {\n      name: \"inlineCode\",\n      components: components,\n      parentName: \"strong\"\n    }, `button`), `s are focusable by default.`)), React.createElement(MDXTag, {\n      name: \"h3\",\n      components: components\n    }, `Keyboard Accessibility pt 2: Events`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `Focusing on an element is only half of the keyboard navigation story. The element should also respond to `, React.createElement(\"kbd\", null, `Enter`), ` or `, React.createElement(\"kbd\", null, `Space`), ` key presses to trigger the same `, React.createElement(MDXTag, {\n      name: \"inlineCode\",\n      components: components,\n      parentName: \"p\"\n    }, `'click'`), ` event. This is a feature that HTML `, React.createElement(MDXTag, {\n      name: \"inlineCode\",\n      components: components,\n      parentName: \"p\"\n    }, `buttons`), ` can give you for free.`), React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-html\"\n      }\n    }, `<div class=\"myBtn\" tabindex=\"0\">Do the thing</div>\n\n<script>\nconst handleClick = (e) => {\n  console.log('myBtn clicked')\n}\nconst handleKeyboardClick = (fn) => {\n  return (e) => {\n    if(e.key === 'Enter' || e.key === ' ') {\n      return fn(e)\n    }\n  }\n}\nconst myBtn = document.querySelector('.myBtn')\nmyBtn.addEventListener('click', handleClick)\nmyBtn.addEventListener('keydown', handleKeyboardClick(handleClick))\n</script>\n`)), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `Take a look at the `, React.createElement(MDXTag, {\n      name: \"inlineCode\",\n      components: components,\n      parentName: \"p\"\n    }, `handleKeyboardClick`), ` function above. This is a small `, React.createElement(MDXTag, {\n      name: \"a\",\n      components: components,\n      parentName: \"p\",\n      props: {\n        \"href\": \"https://www.sitepoint.com/currying-in-functional-javascript/\"\n      }\n    }, `curried function`), ` that accepts a function as a parameter (`, React.createElement(MDXTag, {\n      name: \"inlineCode\",\n      components: components,\n      parentName: \"p\"\n    }, `fn`), `), and returns a function that will guard executing `, React.createElement(MDXTag, {\n      name: \"inlineCode\",\n      components: components,\n      parentName: \"p\"\n    }, `fn`), ` only if the event key is `, React.createElement(MDXTag, {\n      name: \"inlineCode\",\n      components: components,\n      parentName: \"p\"\n    }, `'Enter'`), ` or `, React.createElement(MDXTag, {\n      name: \"inlineCode\",\n      components: components,\n      parentName: \"p\"\n    }, `' '`), ` (Space). This helper can be reused to wrap any additional click handlers that we may need also need to bind later.`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `I'd like to note that this additional event binding isn't necessary if using an HTML button. It will trigger click handlers when Enter or Space is pressed. `), React.createElement(MDXTag, {\n      name: \"h3\",\n      components: components\n    }, `Semantic HTML`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `Now that we can reach the element with a keyboard, let's switch to using another assistive device: a screenreader. A screenreader allows a non-visual user to be able to navigate and read the page content. So what happens when such a user navigates to our non-button? `), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, React.createElement(\"a\", {\n      className: \"gatsby-resp-image-link\",\n      href: \"/static/5f37a3863680f76fdec6f30d3eac7021/efdba/dothething-div-sr.png\",\n      style: {\n        \"display\": \"block\"\n      },\n      target: \"_blank\",\n      rel: \"noopener\"\n    }, React.createElement(\"span\", {\n      className: \"gatsby-resp-image-wrapper\",\n      style: {\n        \"position\": \"relative\",\n        \"display\": \"block\",\n        \"maxWidth\": \"590px\",\n        \"marginLeft\": \"auto\",\n        \"marginRight\": \"auto\"\n      }\n    }, React.createElement(\"span\", {\n      className: \"gatsby-resp-image-background-image\",\n      style: {\n        \"paddingBottom\": \"28.52512155591572%\",\n        \"position\": \"relative\",\n        \"bottom\": \"0px\",\n        \"left\": \"0px\",\n        \"backgroundSize\": \"cover\",\n        \"display\": \"block\"\n      }\n    }), React.createElement(\"img\", {\n      className: \"gatsby-resp-image-image\",\n      style: {\n        \"width\": \"100%\",\n        \"height\": \"100%\",\n        \"margin\": \"0px\",\n        \"verticalAlign\": \"middle\",\n        \"position\": \"absolute\",\n        \"top\": \"0px\",\n        \"left\": \"0px\",\n        \"boxShadow\": \"inset 0px 0px 0px 400px white\"\n      },\n      alt: \"This screenshot shows that when focused on the non-button element, the screenreader only identifies only inner text of 'Do the thing'.\",\n      title: \"\",\n      src: \"/static/5f37a3863680f76fdec6f30d3eac7021/ec4a5/dothething-div-sr.png\",\n      srcSet: \"/static/5f37a3863680f76fdec6f30d3eac7021/f01f3/dothething-div-sr.png 148w,\\n/static/5f37a3863680f76fdec6f30d3eac7021/d6acc/dothething-div-sr.png 295w,\\n/static/5f37a3863680f76fdec6f30d3eac7021/ec4a5/dothething-div-sr.png 590w,\\n/static/5f37a3863680f76fdec6f30d3eac7021/efdba/dothething-div-sr.png 617w\",\n      sizes: \"(max-width: 590px) 100vw, 590px\"\n    })))), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `Let's compare this with an actual button, which I've added underneath the non-button button. `), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, React.createElement(\"a\", {\n      className: \"gatsby-resp-image-link\",\n      href: \"/static/22413e165306dc2d3ba30944854cf1a4/79b0b/dothething-btn-sr.png\",\n      style: {\n        \"display\": \"block\"\n      },\n      target: \"_blank\",\n      rel: \"noopener\"\n    }, React.createElement(\"span\", {\n      className: \"gatsby-resp-image-wrapper\",\n      style: {\n        \"position\": \"relative\",\n        \"display\": \"block\",\n        \"maxWidth\": \"590px\",\n        \"marginLeft\": \"auto\",\n        \"marginRight\": \"auto\"\n      }\n    }, React.createElement(\"span\", {\n      className: \"gatsby-resp-image-background-image\",\n      style: {\n        \"paddingBottom\": \"28.431372549019606%\",\n        \"position\": \"relative\",\n        \"bottom\": \"0px\",\n        \"left\": \"0px\",\n        \"backgroundSize\": \"cover\",\n        \"display\": \"block\"\n      }\n    }), React.createElement(\"img\", {\n      className: \"gatsby-resp-image-image\",\n      style: {\n        \"width\": \"100%\",\n        \"height\": \"100%\",\n        \"margin\": \"0px\",\n        \"verticalAlign\": \"middle\",\n        \"position\": \"absolute\",\n        \"top\": \"0px\",\n        \"left\": \"0px\",\n        \"boxShadow\": \"inset 0px 0px 0px 400px white\"\n      },\n      alt: \"In contrast, this screenshot shows that when the button is focused the screenreader identifies 'Do the thing, button'.\",\n      title: \"\",\n      src: \"/static/22413e165306dc2d3ba30944854cf1a4/ec4a5/dothething-btn-sr.png\",\n      srcSet: \"/static/22413e165306dc2d3ba30944854cf1a4/f01f3/dothething-btn-sr.png 148w,\\n/static/22413e165306dc2d3ba30944854cf1a4/d6acc/dothething-btn-sr.png 295w,\\n/static/22413e165306dc2d3ba30944854cf1a4/ec4a5/dothething-btn-sr.png 590w,\\n/static/22413e165306dc2d3ba30944854cf1a4/79b0b/dothething-btn-sr.png 612w\",\n      sizes: \"(max-width: 590px) 100vw, 590px\"\n    })))), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `It shouldn't be any surprise to see that a div semantically doesn't represent anything. It should also be noted that the CSS class name that we're using to select this element offers nothing for assistive tech to identify. Also not surprising is that the HTML button is identfied as a button. `), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `We can fix this by adding the correct aria-role attribute. If you haven't yet read through the `, React.createElement(\"a\", {\n      className: \"link\",\n      href: \"https://www.w3.org/TR/wai-aria-practices-1.1/\"\n    }, `WAI-ARIA Authoring Practices`), ` it is time you did. It outlines the following:`), React.createElement(MDXTag, {\n      name: \"ul\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"li\",\n      components: components,\n      parentName: \"ul\"\n    }, `If this control is a `, React.createElement(MDXTag, {\n      name: \"em\",\n      components: components,\n      parentName: \"li\"\n    }, `push button`), `, it needs a `, React.createElement(MDXTag, {\n      name: \"inlineCode\",\n      components: components,\n      parentName: \"li\"\n    }, `role=\"button\"`), ` to designate it as an interactive button`), React.createElement(MDXTag, {\n      name: \"li\",\n      components: components,\n      parentName: \"ul\"\n    }, `if this control is a `, React.createElement(MDXTag, {\n      name: \"em\",\n      components: components,\n      parentName: \"li\"\n    }, `toggle button`), `, it needs `, React.createElement(MDXTag, {\n      name: \"inlineCode\",\n      components: components,\n      parentName: \"li\"\n    }, `role=\"button\"`), ` and `, React.createElement(MDXTag, {\n      name: \"inlineCode\",\n      components: components,\n      parentName: \"li\"\n    }, `aria-pressed`), ` attributes, and `, React.createElement(MDXTag, {\n      name: \"inlineCode\",\n      components: components,\n      parentName: \"li\"\n    }, `aria-pressed`), ` is updated to reflect the current state of the control (eg. `, React.createElement(MDXTag, {\n      name: \"inlineCode\",\n      components: components,\n      parentName: \"li\"\n    }, `aria-pressed=\"true\"`), `)`)), React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-html\"\n      }\n    }, `<div class=\"myBtn\" tabindex=\"0\" role=\"button\">Do the thing</div>\n<!--- OR --->\n<div class=\"myBtn\" tabindex=\"0\" role=\"button\" aria-pressed=\"false\">Do the thing</div>\n\n<script>\nconst handleClick = (e) => {\n  console.log('myBtn clicked')\n  // Update aria-pressed for toggle buttons\n  const pressed = e.target.getAttribute('aria-pressed') === 'true'\n  e.target.setAttribute('aria-pressed', pressed);\n}\nconst handleKeyboardClick = (fn) => {\n  return (e) => {\n    if(e.key === 'Enter' || e.key === ' ') {\n      return fn(e)\n    }\n  }\n}\nconst myBtn = document.querySelector('.myBtn')\nmyBtn.addEventListener('click', handleClick)\nmyBtn.addEventListener('keydown', handleKeyboardClick(handleClick))\n</script>\n`)), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"a\",\n      components: components,\n      parentName: \"p\",\n      props: {\n        \"href\": \"https://developer.paciellogroup.com/blog/2011/04/html5-accessibility-chops-just-use-a-button/\"\n      }\n    }, `Just`), ` `, React.createElement(MDXTag, {\n      name: \"a\",\n      components: components,\n      parentName: \"p\",\n      props: {\n        \"href\": \"https://www.youtube.com/watch?v=CZGqnp06DnI\"\n      }\n    }, `use`), ` `, React.createElement(MDXTag, {\n      name: \"a\",\n      components: components,\n      parentName: \"p\",\n      props: {\n        \"href\": \"https://formidable.com/blog/2014/05/08/anchors-buttons-and-accessibility/\"\n      }\n    }, `a button`), `.`));\n  }\n\n}"},"frontmatter":{"title":"Accessible Buttons","date":"Oct 01, 2018","tags":["javascript","a11y"]}}},"pageContext":{"slug":"/accessible-buttons/"}}